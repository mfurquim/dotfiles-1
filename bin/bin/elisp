#!/bin/sh
# provide a way to run elisp in a running emacs-server
# can act as a shebang (ie #!/usr/bin/env elisp) or
# adhoc code (ie elisp '(message "uwu")')

trim=false
if [ "$1" = "-r" ]; then
   trim=true
   shift
fi

running_script=false
if [ -f "$1" ]; then
    running_script=true
    script_name=$1
    shift
fi

eclient="emacsclient"
if [ ! -z "$(uname | awk '$1 ~ /MINGW|MSYS/ {print $1}')" ]; then
    # windows
    eclient="${eclient}w --server-file ${HOME}/.emacs.d/server/${EMACS_SERVER_FILE:-emacs-server-file}"
fi

if [ -z "$script_name" ]; then
    elisp_timeout=1
    lisp="(progn $@)"
else
    trim=true
    elisp_timeout=15 # arbitrary

    args=
    for a in "$@"; do
	args="${args} \"${a}\""
    done

    # todo: consider passing stdin
    lisp="(ns/eval-file \"${script_name}\" ${args})"
fi

emacs_timeout=
if type timeout >/dev/null; then
    emacs_timeout="timeout ${elisp_timeout}"
fi

# echo "$lisp"
result=$($emacs_timeout $eclient --eval "$lisp")

if [ $? -eq 1 ]; then
    # we could not reach emacs, or we timed out.
    exit 1
fi

if [ "$result" = "nil" ] || [ -z "$result" ]; then
  exit 1
fi

if $trim; then
    case "$result" in
	# (1 2 3) -> # 1 2 3
	"("*) echo "$result" | sed -e 's/^(//' -e 's/)$//' ;;
	# "\"~/.dotfiles/bin/bin/elisp\n~/.emacs.d/recentf\""
	# -> "~/.dotfiles/bin/bin/elisp$'\n'~/.emacs.d/recentf"
	'"'*) result=$(printf "$result")
	      echo "${result:1:${#result}-2}" ;;
	# just print it
	*) echo "$result" ;;
    esac
else
    echo "$result"
fi

exit 0
