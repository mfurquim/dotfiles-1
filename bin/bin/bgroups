#!/usr/bin/env joker
;; -*- mode: clojure -*-
;; want: a cider for joker

(require '[joker.os :as os])
(require '[joker.core :as core])
(require '[joker.string :as str])
(require '[joker.set :as set])
(require '[joker.io :as io])

(defn sh [command]
  (:out (apply os/sh (str/split command #" "))))

;; (require '[clojure.java.shell :as shell])
;; (defn sh [command]
;;   (:out (apply shell/sh (str/split command #" "))))

;; todo: make load and save state locking/defaults
(defn load-state []
  (def state
    {:groups
     [{:name "01" :wids #{1} :active true}
      {:name "02" :wids #{} :active true}
      {:name "03" :wids #{} :active true}
      {:name "04" :wids #{} :active true}]
     :focus-wid ""
     :fifo "/tmp/bspgroups"
     :monitor (-> "bspc query -M -m --names" sh str/trim-newline)
     }))

(load-state)

(defn save-state []
  ;; nope
  )

(defn render-wid [wid show]
  (sh (core/format "bspc node %s -g hidden=%s" wid (if show "off" "on"))))

;; (println (core/format "bspc node %s -g hidden=%s" wid (if show "off" "on")))
(defn render-state []
  ;; show/hide status
  (let [show-wids
        (->> (:groups state)
             (filter :active)
             (map :wids)
             (apply set/union))
        hide-wids
        (->>(:groups state)
            (map :wids)
            (apply set/union) ;; all group wids
            (set/difference show-wids)) ;;
        ]

    (doall (map #(render-wid % true) show-wids))
    (doall (map #(render-wid % false) hide-wids)))

  ;; refocus who we had if they exist
  (when (not (= (:focus state) ""))
    ;; (sh "bspc config pointer_follows_focus true")
    (sh (core/format "bspc node %s -f" (:focus state)))
    ;; (sh "bspc config pointer_follows_focus false")
    ))

(defn group-focus [group]
  "focus the last known window in the group - also note it as the focused pid"
  )

(defn group-toggle [& groups]
  "toggle visibility of the group"
  (->> (:groups state)
       (filter :active)
       ;; (contains?) is weird -- is index on seqs, no value
       ;; and on sets can be value since they are the same thing
       (filter #(contains? (set groups) (:name %)))
       (map (update))
       (map :wids)
       (apply set/union))
  )

(defn action-group-names
  "get all the group names"
  [] (->> state :groups (map :name) (map println) doall))

(defn get-group-wids [& groups]
  "get all wids in a group or groups"
  (->> (:groups state)
       (filter :active)
       ;; (contains?) is weird -- is index on seqs, no value
       ;; and on sets can be value since they are the same thing
       (filter #(contains? (set groups) (:name %)))
       (map :wids)
       (apply set/union)))

(defn toggle-group [group]
  (let [lgroup (keyword (str group))]
    (def state
      (update
       state :active
       #(if ((:active state) lgroup)
          (disj % lgroup)
          (conj % lgroup))))
    (group-focus lgroup)))

(defn toggle-wid-group [wid group]
  (def state
    (update state
            :groups
            (fn [groups]
              (update groups
                      (keyword (str group))
                      #(if (% wid)
                         (disj % wid)
                         (conj % wid))))))

  (group-focus (keyword (str group))))

;; return a version of state similar to bspc subscribe
;; ref: WMDVI-D-0:O00:o01:f10:f11:LM:TT:G
(defn group-to-print-section [group]
  (let [char (-> (:wids group) empty? (if "f" "o"))]
    (format "%s%s"
            (if (:active group) (str/upper-case char) char)
            (:name group))))

(defn action-print-state
  "print the state matching bspc subscribe format"
  []
  (println
   (str/join ":" (concat
                  (list "WM" (:monitor state))
                  (map #'group-to-print-section (:groups state))
                  '("LT" "TT" "G")))))

(defn usage
  "generate usage from docstring of action-* functions"
  []
  (->> (ns-map *ns*)
       keys
       (map str)
       (filter #(str/starts-with? % "action-"))
       (map #(format "%s: %s"
                     (subs % (count "action-"))
                     ;; so hot
                     (-> % symbol resolve meta :doc)))
       (cons "commands: ")
       (map println)
       doall
       ))

(defn action--h "usage" []
  (usage))

(if *command-line-args*
  (apply
   (->> *command-line-args* first (concat "action-") (apply str) symbol resolve)
   (rest *command-line-args*))
  (action--h))
