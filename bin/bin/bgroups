#!/usr/bin/env joker
;; -*- mode: clojure -*-
;; want: a cider for joker

(require '[joker.os :as os])
(require '[joker.core :as core])
(require '[joker.string :as str])
(require '[joker.set :as set])
(require '[joker.io :as io])

(defn sh [command]
  (:out (apply os/sh (str/split command #" "))))

;; (require '[clojure.java.shell :as shell])
;; (defn sh [command]
;;   (:out (apply shell/sh (str/split command #" "))))

;; todo: make load and save state locking/defaults
(defn load-state []
  (def state
    {:groups
     [{:name "01" :wids #{1} :active true}
      {:name "02" :wids #{} :active true}
      {:name "03" :wids #{} :active true}
      {:name "04" :wids #{} :active true}]
     :focus-wid ""
     :fifo "/tmp/bspgroups"
     :monitor (-> "bspc query -M -m --names" sh str/trim-newline)
     }))

(load-state)

(defn save-state []
  ;; nope
  )

(defn render-wid [wid show]
  (sh (core/format "bspc node %s -g hidden=%s" wid (if show "off" "on"))))

;; (println (core/format "bspc node %s -g hidden=%s" wid (if show "off" "on")))
(defn render-state []
  ;; show/hide status
  (let [show-wids
        (->> (:groups state)
             (filter :active)
             (map :wids)
             (apply set/union))
        hide-wids
        (->>(:groups state)
            (map :wids)
            (apply set/union) ;; all group wids
            (set/difference show-wids)) ;;
        ]

    (doall (map #(render-wid % true) show-wids))
    (doall (map #(render-wid % false) hide-wids)))

  ;; refocus who we had if they exist
  (when (not (= (:focus state) ""))
    ;; (sh "bspc config pointer_follows_focus true")
    (sh (core/format "bspc node %s -f" (:focus state)))
    ;; (sh "bspc config pointer_follows_focus false")
    ))

(defn action-focus "focus <group names>"
  [& groups]
  )

(defn action-toggle
  "toggle <group names>"
  [& groups]
  (def state
    ;; (contains?) is weird -- is index on seqs, no value
    ;; and on sets can be value since they are the same thing
    ;; (filter #(contains? (set groups) (:name %)))
    (update
     state
     :groups
     (fn [old-groups]
       (concat
        ;; unchanged (filter and just keep)
        (filter #(not (contains? (set groups) (:name %))) (:groups state))

        ;; changing (filter and change)
        (->> (:groups state)
             (filter #(contains? (set groups) (:name %)))
             (map #(update % :active (fn [old-active] (not old-active)))))

        )))))

(defn action-names
  "get all the group names"
  [] (->> state :groups (map :name) (map println) doall))

(defn get-group-wids [& groups]
  "get all wids in a group or groups"
  (->> (:groups state)
       (filter :active)
       ;; (contains?) is weird -- is index on seqs, no value
       ;; and on sets can be value since they are the same thing
       (filter #(contains? (set groups) (:name %)))
       (map :wids)
       (apply set/union)))

;; need to update this
;; (defn toggle-wid-group [wid group]
;;   (def state
;;     (update state
;;             :groups
;;             (fn [groups]
;;               (update groups
;;                       (keyword (str group))
;;                       #(if (% wid)
;;                          (disj % wid)
;;                          (conj % wid))))))

;;   (group-focus (keyword (str group))))

;; return a version of state similar to bspc subscribe
;; ref: WMDVI-D-0:O00:o01:f10:f11:LM:TT:G
(defn group-to-print-section [group]
(let [char (-> (:wids group) empty? (if "f" "o"))]
  (format "%s%s"
          (if (:active group) (str/upper-case char) char)
          (:name group))))

(defn action-state
  "print the state matching bspc subscribe format"
  []
  (println
   (str/join ":" (concat
                  (list "WM" (:monitor state))
                  (map #'group-to-print-section (:groups state))
                  '("LT" "TT" "G")))))

(defn usage
  "generate usage from docstring of action-* functions"
  []
  (->> (ns-map *ns*)
       keys
       (map str)
       (filter #(str/starts-with? % "action-"))
       (sort)
       (map #(format "%s: %s"
                     (subs % (count "action-"))
                     ;; so hot
                     (-> % symbol resolve meta :doc)))
       (cons "commands: ")
       (map println)
       doall
       ))

(defn action--h "usage" []
  (usage))

(action-state)
(action-toggle "01")
(action-state)
(action-toggle "01")
(action-state)

;; (if *command-line-args*
;;   (apply
;;    (->> *command-line-args* first (concat "action-") (apply str) symbol resolve)
;;    (rest *command-line-args*))
;;   (action--h))
