#!/usr/bin/env joker
;; -*- mode: clojure -*-

;; a hack for cider buffer repl
(defmacro cider-nop [& contents] (when nil contents))
(cider-nop
 (do (require '[clojure.core :as core])
     (require '[clojure.string :as str])
     (require '[clojure.set :as set])
     (require '[clojure.java.io :as io])
     (require '[clojure.java.shell :as shell])

     (defn sh [command]
       (:out (apply shell/sh (str/split command #" "))))
     )

 )

;; the read stuff
(require '[joker.os :as os])
(require '[joker.core :as core])
(require '[joker.string :as str])
(require '[joker.set :as set])
(require '[joker.io :as io])

(defn sh [command]
  (:out (apply os/sh (str/split command #" "))))

;; todo: make load and save state locking/defaults
(defn load-state []
  (def state
    {:groups
     [{:name "01" :wids #{1} :active true}
      {:name "02" :wids #{} :active true}
      ;; {:name "03" :wids #{} :active true}
      ;; {:name "04" :wids #{} :active true}
      ]

     ;; track the focused wid before an action
     :focus-wid ""
     ;; allow focusing a group to toggle it
     ;; :focus-group ""

     :fifo "/tmp/bspgroups"
     :monitor (-> "bspc query -M -m --names" sh str/trim-newline)
     }))

(defn save-state []
  ;; nope
  )

(defn render-wid [wid show]
  (when (empty? (sh (format "bspc query -N -n %s.%shidden" wid (if show "" "!"))))
    (sh (format "bspc node %s -g hidden=%s" wid (if show "off" "on")))))

;; (println (core/format "bspc node %s -g hidden=%s" wid (if show "off" "on")))
(defn render-state []
  ;; show/hide status
  (let [show-wids
        (->> (:groups state)
             (filter #(or (:active %)
                          (= (:name %) (:focus-group state))))
             (map :wids)
             (apply set/union))
        hide-wids
        (->>(:groups state)
            (map :wids)
            (apply set/union) ;; all group wids
            (set/difference show-wids)) ;;
        ]

    (doall (map #(render-wid % true) show-wids))
    (doall (map #(render-wid % false) hide-wids)))

  ;; refocus who we had if they exist
  (when (not (= (:focus-wid state) ""))
    ;; (sh "bspc config pointer_follows_focus true")
    (sh (core/format "bspc node %s -f" (:focus state)))
    ;; (sh "bspc config pointer_follows_focus false")
    ))

(defn action-focus "focus <group name>"
  [group]
  ;; focus the last window in the group
  (println (format "calling with %s" group))
  (def state
    (update state :focus-wid
            (fn [_]
              (->> (:groups state)
                   (filter #(= (:name %) group))
                   first :wids last)
              ))))

(defn update-groups [transform-func]
  (def state
    (update state :groups
            (fn [old-groups]
              (doall
               (map transform-func old-groups))))
    )
  )

(defn action-toggle
  "toggle <group names>"
  [& groups]

  (defn update-active [old-group]
    ;; note: (contains?) is weird -- is index on seqs, no value
    ;; and on sets can be value since they are the same thing
    (update old-group :active
            (fn [_] (if (contains? (set groups) (:name old-group))
                      (not _) _))))

  (update-groups update-active))

(defn action-names
  "get all the group names"
  [] (->> state :groups (map :name) (map println) doall))

(defn action-wids
  "wids <group names> - get all wids in a group or groups"
  [& groups]
  (->> (:groups state)
       (filter :active)
       ;; (contains?) is weird -- is index on seqs, no value
       ;; and on sets can be value since they are the same thing
       (filter #(contains? (set groups) (:name %)))
       (map :wids)
       (apply set/union)
       (map println) doall
       ))

(defn action-toggle-wids
  "toggle <group> <wids> -- toggle wids being in a group"
  [group & wids]
  (defn update-wids [old-group]
    (update old-group :wids
            (fn [old-wids]
              (set/union
               ;; existing minus toggles
               (set/difference old-wids wids)
               ;; new (old filter for not in new?)
               (set (filter #(not (contains? old-wids %)) wids))
               ))))

  (update-groups update-wids))

;; return a version of state similar to bspc subscribe
;; ref: WMDVI-D-0:O00:o01:f10:f11:LM:TT:G
(defn group-to-print-section [group]
  (let [char (-> (:wids group) empty? (if "f" "o"))]
    (format "%s%s"
            (if (:active group) (str/upper-case char) char)
            (:name group))))

(defn action-state
  "print the state matching bspc subscribe format"
  []
  (println
   (str/join ":" (concat
                  (list "WM" (:monitor state))
                  (map #'group-to-print-section (:groups state))
                  '("LT" "TT" "G")))))

(defn usage
  "generate usage from docstring of action-* functions"
  []
  (->> (ns-map *ns*)
       keys
       (map str)
       (filter #(str/starts-with? % "action-"))
       (sort)
       (map #(format "%s: %s"
                     (subs % (count "action-"))
                     ;; so hot
                     (-> % symbol resolve meta :doc)))
       (cons "commands: ")
       (map println)
       doall
       ))

(defn action--h "usage" []
  (usage))

(load-state)

;; (action-state)
;; (prn state)

(if *command-line-args*
  (apply
   (->> *command-line-args* first (concat "action-") (apply str) symbol resolve)
   (rest *command-line-args*))
  (action--h))

;; (action-state)
;; (prn state)

;; (render-state)
(save-state)
